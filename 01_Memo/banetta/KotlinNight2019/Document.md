#   Kotlin Night 2019

##  KeyNote - 인공지능은 프로그래머를 대체할까?   -   김상균 교수

2039년 4월 8칠
20년 뒤, 나는 무엇을 하고 있을까? 나의 직업은 무엇일까?

-   Will google be replace by AI/Robot?
    -   Actors  37,500,00
    -   Chefs   54,400,00
    -   Doctors 57,300,00
    -   Judges  62,000,000
    -   Programmers 136,000,000
    -   Writers

    -   Programmers가 대체될거같은 순위 2위
    -   Professers가 1위

-   Push vs. Pull
    -   인간의 직업이 무언가에 의해서 계속 변화되고 있다.
    -   밀려나거나 내가 직접 내놓고 다른것으로 대체
    -   <images>

-   프로그래머로서 나는 무엇을 잘할까요?
    -   DeepMind Starcraft 해설가들의 평가
        -   인공지능이 인간보다 더 정밀하게 조작이 가능했다
        -   굉장히 빠른속도로 처리함
        -   인간과 다르게 지치거나 멘탈이 흔들리지 않고 일관적으로 진행함
    -   인공지능이 현재 평가받는 부분과 굉장히 유사함
    -   딥마인드의 정확도가 93%가 넘어감
    -   처리속도 역시 굉장히 빨라짐
    -   왓슨은 한번 판단하기 위해 의학정보 60만건과 환자정보 153?만건정도 접근해서 판단

-   Big Question
    -   AI가 내 직업을 대체하면, 나는 무엇을 해서 돈을 벌까?
        -   현재 거의 모든 직업이 20년 내에 전부 대체될것으로 예측함
    -   AI가 대체하지 못하는 직업/학과가 무엇인가요?
        -   제 직업에 대해서도 잘 모르는데 다른 직업이라고 알수 있을까?
        -   원론적인 이야기로는 현재로 두고 보면 AI와 비교하면 공감력, 소통능력, 전략적인 판단능력, 창의력등이 뛰어나지 않는가? 이런 분야에 관련된 직업이나 학과를 가면 어떻겠는가?
        -   그러나 이게 정론은 아님
        -   가장 많은 사람들이 이야기하는것이 AI가 인간의 창의력을 뛰어넘지 못할것이라 했지만, 일본에서 AI가 집필한 소설을 문학상에 대해 제출했는데 상을 받지는 못했지만 1차 심사를 통과한 자료가 많은편
    -   AI가 인간 직무를 대신하는 시대, 인간의 궁극적 가치는 무엇일까?
        -   스웨덴에 있는 일자리중 2025년에 오픈되는 구텐베르크 기차역에 굉장히 독특한 자리가 있는데 초봉 300만원에 복지 다되고 죽을 때까지 종신고용이다.
        -   120세까지 살아있으면 돈을 계속 지급할것
        -   아침에 출근해서 책상에 버튼이 있는데 누르고 자기 마음대로 행동, 퇴근시간에 다시 책상에 버튼을 누르고 퇴근
        -   이데 필요한 예산까지 벌써 마련을 다 해둠
        -   이 프로젝트의 명칭은 이터널 임플로이먼트 프로젝트
        -   프로젝트 제작자의 의견은 인간의 일자리는 무언가에 의해 계속 달라질수 밖에 없고 인류가 지향하는 방향은 생산성,... 이다.
        -   인간은 어느 길로 어느 방향으로 가야할까? 라는 의문점을 던지기 위해 스웨덴에서는 이 프로젝트를 준비하고 있음
        -   인간이 만든 AI에 의해서 Pull(이끌어나가는)것 같았지만 결국엔 Push(밀려나는) 상황이 될것
        -   인류는 생산성이란 것을 버렸을 때, 무슨 일을 할것인가?
        -   당신의 직무의 대한 가치는 어떻게 변할것인가?
        -   지금의 예측은 앞으로 단 20년이 남았다.


##  자바 개발자 관점의 - 왜 코틀린인가? -   카카오페이 강현식

-   Who Are You?
    -   9년차 자바/코틀린 개발자
    -   카카오 페이 Firm Banking Gateway Developer
        -   With Fully Kotlin Production Project
        -   With Java+Kotlin Production Project
    -   line/Coupang Commerce, etc
        -   Kotlin 1도 안해봄

-   Target  -   이 세미나를 쉽게 Java or JVM Language 중금
    -   함수형 프로그래밍
    -   Reactive 프로그래밍
    -   Clean Code 지향
    -   자바로 웬만한건 해봤다(?)

-   이런 의문을 가진사람들이 괜찮게 들을것
    -   코틀린 쉽게 쓸수있을까?
    -   자바를 대체할 수 있을까?
    -   스칼라 어렵던데 어려울까?
    -   바로 대체하기 힘드니 같이못쓸까/

-   단 모든 피쳐는 못함

-   이번 세미나에서 주로 다룰것
-   코틀린과 자바를 비교하여 오래쇤 자바 개발자인 제가 코틀린을 선택한 이유에 대한 것에 대해 
-   코틀린의 인상적인 기능

-   자바는 좋은언어이나 너무 장황하다!

-   엔티티 설계 및 테스트
    -   객체생성이 불편하고 리스트 만들떄가 굉장히 불편
    -   물론 구아바나 jdk 9을 쓰면 편해짐

-   그러나 jdk9은 아직 많이 사용하지 않고..

-   그렇다면 빌더 패턴을 이용해보자

-   벌써 장황한데..

-   Lombok을 이용하면 간단해짐

-   아무 문제 없는것 아닌가?
    -   But 해야할 절차가 굉장히 많음

-   코틀린은?

-   data class = Lombok의 @data

-   wkqkdml dpzh tltmxpa(tmvmfld, JPA, reactor, Netty등)을 활용하고싶은데 자바에 불만이 있음

-   코틀린에서 자바의 려ㅣㅣㅛ ghghksehla
-   자바 -> 코틀린 호출도 가능

-   자바코드를 apply에 사용하기 위해 setter..
-   Class 내의 var/val은 사실 = getter/setter와 같음

-   필드를 클래스내부에서만 쓰고 공개하고 싶지 않으면...

-   listOf도 자바의 java.util.List로 그대로 전환 가능(상호 호환)
-   자바의 또다른 대안으로 스칼라가 있지만..<이미지>
-   그렇다고해서 스칼라가 나쁜건아니고 둘다 좋다고 생각함

-   젯브래인 아이디어 굳굳ㄱ두ㅜ구둑두

-   자바 코드 코틀린 변환은 완벽하지는 않지만, 그만큼 진입 장벽을 많이 내릴수 있다.

-   멀티 플랫폼 지원
    -   JVM, 안드로이드, 자바스크립트(브라우저에서 사용 가능), 네이티브(아직은 성숙하지 못함)

    - 2017 google i/O에서 안드로이드 정식 언어로 채택

-   JDK 6 이상부터 지원(안드로이드 기기) 스칼라도 동일
-   Null Pointer Exception 왠만에선, 코틀린에선 불가!
-   NULl을 완전히 없엘수는 없었음
-   컴파이러 레벨에서 NPE를 막아줌
-   언어차원의 NPE 방지로 인해 많은 버그를 없엘 수 있음
-   Elvis Operator

-   wkqkfh wkrtjdehls ahems xkdlqdms sjf tpdlvm qhwkd qnfrk
-   zhxmfflsdmfh wkrtjehlTdmf Eoaks rksmd
-   확장함수
    -   기존 클래스를 변경하지않고 함수 추가 가능
    -   코틀린 언어차원에서 미리 정의한 확장함수가 아닌 경우 외부파일에서 확장 메소드 사용할 때에는 import 필요
    -   Java에서 코틀린의 확장 함수는 그냥 외부 스태틱 메소드로 보이기 떄문에 활용도가 떨어짐

-   apply
    -   C++의 인라인 함수와 비슷
    -   함수를 받아와서 실행 한 뒤 자기 자신을 리턴

-   JDK 7,8 이상부터 확장 기능을 편하게 사용하게 제공

-   Kotlin에서 조심해서 사용해야 하는 기능
-   코틀린의 놀라운 편의성을 갖춘 확장함수들


-   아주 유용한 Data Class


-   달라진 if와 새로운 when
    -   if는 구문이 아닌 식으로 변경, 즉 결과값을 데이터로? 삽입 가능
    -   if가 삼항연산자를 완전히 대체 하기 때문에 코틀린에는 삼항 연산자가 없음
    -   when은 switch를 대체하기 위해 나온 언어
    -   switch에서 안됬던 메소드를 집어넣거나, 추가적인 다른 기능이 포함됨

-   zhxmfflsdms wkqkqhek whaej gkatngud djsdjdp rkRkdna
-   코틀린에서는 일급함수 객체?
-   함수가 일극객체
-   자바에서는 함수를 리턴, 전달할 수없음 다만 문법적 설탕으로 람다에선 가능
-   자바에서는 함수를 변수에 저장할 수없음
-   마찬가지로 람다에서 표현 가능
-   코틀린에서는 일급객체로서 가능하다.
-   파라메터 전달 예제는 apply가 대표적연산자의 의미를 재정의
-   c++등에선 이미 지원했었는데
-   자바에서 안됬지만 코틀린에선 가능함


##  이펙티브 자바와 코틀린  -   이스트소프트 전경주

-   Effcctive Java
-   생성자에 매개변수가 많다면 빌더를 고려하라
-   private생성자나 열거 타입으로 싱글턴임을 보증하라
-   인스턴트화를 막으려면......

-   Effective Java의 지침들이 코틀린에서 반영되어있어 비슷한 방향으로 코드를 짜면 좋겠네! 라는 생각

-   Effective Java의 내내용들을 코틀린에서는 어떻게 적용되는지 점점 이펙티브 코틀린으로 생각이 변해감

-   생성자에 매개변수가 많다면 빌더를 고려하라
    -   어떤것을 필수로 받게할지 선택을 받게 살건지 생각
    -   점층적 생성자 패턴
        -   숫자들이 뜻하는 바를 알기 어려움
        -   중간 필드만 기본값으로 처리할 수 없음
    -   자바 빈즈 패턴
        -   클래스를 불변으로 만들 수 없음
        -   스레드 안정성 없음   
        -   Boilerplate 코드가 많다
        -   Default argumants를 통해 기본값 할당
        -   Named arguments를 통해 어떤 필드에 값이 들어가는지 명확하게 표현

    -   매개변수가 많다면 Named arguments와 Default argumentts로 가독성을 높이자

-   private 생성자나 열거 타입으로 싱글턴임

    -   싱글턴
        -   인스턴스를 오직 하나만 생성할 수 있는 클래스
        -   ㅁ

    -   Object를 통해 메소드이자 객체가 가능
    -   Decompile 해본다면?
        -   자바로 구현한 방식과 유사하게 나옴
    -   싱글톤은 object 키워드를 통해 생성 가능

-   인스턴스화를 막으려거든 private 생성자를 이용하라
    -   왜 인스턴스화를 막아야 하는지?
        -   이따금 단순히 정적 메서드와 정적 필드만을 담은 클래스를 만들고 싶을 떄가 있을것이다.
        -   정적 맴버만 담은 유틸리티 클래스는 인스턴스....

    -   인스턴스화를 막을 목적이 유틸 클래스라면 Top Level func를 이용

-   상속보다는 컴포지션을 사용하라
    -   컴포지션 : 새로운 클래스를 만들고 기봊 클래스를 필드로 사용
    -   예제를 통해 둘 비교
    -   intrumentedHashSet 구현
    -   원소를 몇번 더했는지 기록할 수 있는 HashSet

    -   상속은 캡슐화를 꺠트린다. 자식 클래스가 부모 클래스의 상세 구현에 의존하게 되기 대문
    -   상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자. 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다. 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.


    -   상속보다는 컴포지션을 사용하라. 코틀린에는 래퍼 클래서를 by 키워드를 통해 가능

-   상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지해라
    -   상속을 왜 막아야 하는가
        -   클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야 하며, 추후에 바꾸기 어렵다
        -   내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있다.
        -   클래스를 확장해야할 ㅁ넝라ㅣ멍ㄴ리ㅏㅓㅁ

    -   상속을 왜 막아야 하는가 -> 상속을 왜 필요한가 라는 생각으로 전환하게 된 계기

    -   상속을 고려해 설꼐하고 문서화 하라. 상속이 필요한 이유가 있을떄만 상속을 허용하자.

-   public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
    -   접근자 메소드 get(), set() 이용
    -   public 필드
        -   API를 수정하지 않고는 내부 표현을 바꿀 수 없다.
        -   불변식을 보장할 수 없다.
        -   부수 작업을 수행할 수 없다.
        -   결국, 캡슐화 이점을 제공하지 못한다.
    -   코틀린에서는 언어 자체에서 필드에 접근자 메소드를 부르지 않아도 쓸 수있도록 구현됨
    -   Getter, Setter를 선언할 수 있기 때문에 직접 정의 안해도된다

-   @Override 애너테이션을 일관적으로 사용하라
    -   오버라이드를 하지 않고, 오버로딩을 하면 파라미터가 달라져서 결과가 의도와 달라질 수 있음
    -   Object를 파라미터로 받아야 오버라이드 에러 안뜸
    -   코틀린에서는 override가 키워드로 들어가있음

    -   자바에서는 달지 않아도 오버라이딩을 할 수 있었지만, 코틀린에서는 무조건 override 키워드를 붙여야 한다.

-   변경 가능성을 최소화하라
    -   가변 객체와 불변 객체(필드)
        -   가변 객체
            -   임의의 복잡한 상태에 놓일 수 있다.
            -   상태 전이를 정밀하게 문서로 남겨놓지 않은 가변 클래스는 믿고 사용하기 어려울 수 있다.
        -   불변 객체(필드)
            -   객체 생성 이후에 변하지 않는 개체
            -   스레드 안전하여 동기화할 필요 없음
    -   불변 필드로 만들기
        -   자바 : final을 붙이면 됨
        -   코을린 : val을 이용
    -   final vs val 똑같은것 아닌가요?
        -   final 변수 선언 후에, 선택적으로 붙이는 느낌
        -   val, var 변수 선언시 두개중에 하나로 결정
            -   (적어도 저에게는) 변수 선언시에, 변경될만한 필드인지 더 생각해봄
            -   변경 여부에 대햄냉ㅎ

    -   코틀린 리스트와 자바 리스트
        -   코틀린 리스트에는 변경하는 매소드가 정의되어 있지 않음 - Read Only 인터페이스
        -   실제 객체는 멀테이블이더라도 클라이언트에게 리스트타입으로 노출한다면 해당 클라이언트로 하여금 내 리스트가 바뀌지 않도록 할 수 있다.


    -   코틀린에서는 이를 도울만한 도구들이 많이 있다.

-   박싱된 기본타입보다는 기본타입을 이용하라
    -   기본타입
        -   int, duble, boolean등
    -   참조타입
        -   String, list등..
    -   박싱된 참조 타입

    -   기본타입 ㅍㄴ qkrtldehls rlqhs xkdlq
        -   박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다
        -   박싱된 기본 타입은 nulldmf rkwlf tn dlTek

    -   코틀린에서의 박싱된 기본 타입?
        -   코틀린에는 없다
        -   컴파일 하는 과정에서, 박싱된 기본 타입이 필요할때(Nullable, Generices 등)가 아니라면 기본타입으로 컴파일한다.


    -   코틀린은 컴파일러를 통해 박싱 여부를 결정하며 필요한 경우 외에는 기본타입을 사용한다.
    -   이는 숨김 퍼포먼스 저하를 유발할 수 있기 떄문에 잘 고려해야 한다.

-   equals늠 ㅁㄴㅇ럼나이러ㅣㅏㅁㄴㅇㄹ
    -   Java Object equals, Kotlin Any equals 규약
        -   data class를 이용하면 해결

    -   Java HashCode를 구혀나는 간단한 방법
        -   역시 data class를 이용하면 해결

    -   toString을 항상 재정의하라

-   예외를 무시하지 마라
    -   무시한다면?
        -   오류를 내재한 채 동작함
        -   문제의 원인과 아무 상관없는 곳에서 죽어버릴 수 있음
        -   전파되게만 나둬도 디버깅 정보를 남긴 채 프로그램이 신속히 중단되게 할 수 있음
    -   Check Exception
        -   try-catch로 처리하거나, 다시 throw해야만 하는 exception
            -   단점
                -   복구가 불가능한 상황에서도 처리해야함
                -   클라이언트에게 너무 자세한 오류정보를 제공
                -   수많은 개발자들이 처리하지 않고 무시함
    -   코틀린에서는?
        -   Check Exception이 없음
        -   레퍼런스 페이지에선 예시가 있음
        -   예외를 무시하지마라는 여전히 유효하고 Uncheched

    -   없지만 상관없이 무시하지마라

-   지연초기화 는 신중히 사용하라

    -   지연초기화
        -   필드를 사용하는 시점에 초기화
            -   주로 필드 생성 비용이 비쌀때 사용한다.
        -   책에서는, 동기화로 인한 성능 저하를 문제로 삼음
        -   코틀린에서는 ㅁㄴㅇㄹㅁㄴㅇㄹ

    -   쉽게 구현하고 ㅆ

-   한정적 와일드 카드를 사용해 API 유연성을 높혀라


##  Break by GitHub -   Daniel Hwang

-   https://github.com/gnawhleinad/talks

##  Kotlin을 활용한 우아한 코드 만들기  -   SK 플래닛 이수호

-   우아한 코드?
    -   쉽고 편하다
    -   간결하다
    -   명확하다
    -   효율적이다
    -   안전하다
    -   유연하다
    -   확장가능하다
    -   etc...

-   대부분 코드여서 발표자료 업로드시 기록 예정


##  Kotlin+AWS Lambda 와 API Gateway    -   허재위

-   이야기할 내용
    -   코틀린, 그래들 그리고 서버리스 아키텍쳐(SAM)을 이용해서 배포해봅니다.
    -   배포한 API를 사용하는 CLI앱읆 만들어보려합니다.

    -   Build Script역시 코틀린 DSL
-   간단한게 CLI에서 gree

라이브 코딩으로 진행되어 발표자료 업데이트 이후에 보완할것
-   요약
    -   